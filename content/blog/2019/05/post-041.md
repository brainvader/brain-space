+++
title = "Learn OpenGL With Rust (4) Texture"
description = "フラグメント・シェーダとテクスチャ座標"
date = 2019-06-03T10:16:16Z

[taxonomies]
categories = ["programming"]
tags = ["OpenGL", "Computer Graphics", "Rust"]
+++

# OpenGLのテクスチャの扱い

## テクスチャ座標

　OpenGLでは画像をテクスチャと言う形で利用します. 両者は似ていますが通常の画像はピクセルで表現されます. 一方テクスチャ座標は正規化されているので座標は(0.0, 0.0) ~ (1.0, 1.0)の間になります. どちらも画像(色情報を敷き詰めたもの)ですが, テクスチャ座標上ではテクセルと言う単位を使います. OpenGLではテクスチャ座標から色を取得して利用します. このような処理を**サンプリング**と呼びます. この処理は基本的にはシェーダが行うものです.

## テクセル

　テクセルはテクスチャ座標上のピクセル領域のことです. 500×500ピクセルなら500×500テクセルになるはずです. 別の言い方をすると同じ色で塗りつぶされた領域です. テクセル内は同じ色であることが保証されています.

## UV座標

　UV座標は数学(微分幾何学など)では3次元の場合は, 図形の曲面上に定義される2次元座標になります. この際に\\( \bf{x}(u, v) \\)のように座標をパラメータuとvで表すことからパラメータ形式とも呼ばれます. CGではUV座標とテクスチャ座標は同一視されます. ただ定義上は違う気もします. テクスチャはあくまで読み込んだ画像を正規化して管理するためのものです. 一方, UV座標は3Dポリゴンの2次元座標上でのパラメトリックな表現です. ただ画像を表示するためには何らかのポリゴンが必要になりますし, 色が頂点カラーで表現できる場合はUV座標は必要ありません. 両者が必要になるのはテクスチャ・マッピングの場合で, その場合両者の定義は相互に変換可能なものなので, 同一視されるのかもしれません.

## Texture Wrapping

　ややこしいのはテクスチャの値は正規化されているのですが, UV座標はこの範囲外も指定できることなのです. つまり2.0とか-1.0といった値にもアクセスできるのです. しかしサンプリングしてもここには色が存在しません. 存在しない場所からサンプリングを行った場合にどのような挙動をすべきかを定義するのがラッピング・モードです.

1. GL_REPEAT: 同じ画像をタイル状に敷き詰める
2. GL_MIRRORED_REPEAT: タイルの隣接境界線上で鏡合わせになるように敷き詰める
3. GL_CLAMP_TO_EDGE: テクスチャ画像の境界を引き延ばす
4. GL_CLAMP_TO_BORDER: テクスチャ画像のボーダーで区切り, 残った領域を指定色で塗りつぶす.

　gl::TexParameteri関数で指定できるようです.

```rust
gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_WRAP_S, gl::REPEAT as i32);
gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_WRAP_T, gl::REPEAT as i32);
```

　2番目の引数のS/Tというポストフィックスはテクスチャ座標の座標軸を表していると思ってください. 4のGL_CLAMP_TO_BORDERは境界を色で埋めますのでその色も指定する必要があります. その際はfloat vectorのパラメータを渡せるgl::TexParameterfv関数を利用します.

```rust
let borderColor: [f32; 4] = [1.0, 1.0 0.0, 0.0];
gl::TexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);
```

#### クランプとは?

　英語のclampはある範囲に限定すると言うような意味があるそうです. プログラムで制限するのは値の範囲です. ラッピング・モードの説明で良くあるのは, 画像を並べて実験結果を見せると言うやつですが, クランプの意味がうまく説明されていません. ドキュメントを読みましょう.{{ ref(id=1) }} ドキュメントではGL_CLAMP_TO_EDGEは

> the texture coordinate is clamped to the [0, 1] range.

　と説明されています. 一方, GL_CLAMP_TO_BORDERは, 

> the texture coordinate is clamped to the [0, 1] range, but the edge texels are blended with a constant border color.

　と前半は同じです. [0, 1]に制限すれば色の未定義領域は存在しなくなります. そのため[0, 1]の範囲を超えた物を強制的に[0, 1]にクランプするわけです. すると1.1も1.5, そして2.0も全て1.0に変換されます. そのためテクスチャ画像の境界の色が伸びるような画像になるわけです. GL_CLAMP_TO_BORDERは一番普通の挙動になります. 色がない場所はユーザー指定の色に

<!-- TODO: Blendingの意味を考える -->

### フィルタリング

　テクスチャ座標は正規化されていますが浮動小数点で表現できますが, 色はテクセル未満には分解できません. ピクセルもピクセルも単色で塗りつぶされた正方形と思えば良いです. 問題はテクスチャ座標がテクセルの角あたりを指している場合です. もし色が連続的に表現されていたら(解像度が無限大だったら)別の色の可能性もあります. しかしテクセルは離散化されているのでそのような細かな色を表現することはできません. 特に解像度が低い画像を拡大表示するようなケースでブロックノイズとなってテクセルの形が見えてしまいます. こうした作為を低減して色を正確に再現するためにフィルタリングと言うのを行います.
　フィルタはある成分だけを取り出すもののことです. ここでは特定の色を取り出すために施される処理のことです.

+ GL_LINEAR: 一番近いテクセルと取り出す.
+ GL_NEAREST: 近傍の色を平均した色を取り出す.

　GL_NEARESTは近傍平滑化と呼ばれる処理でブロックノイズを低減します. ただしピクセル・アートを平滑化してしまうと台無しなので表現によってフィルタを選ぶことになるようです.

### mipmas

　

## Reference
{{ anchor(id=1) }} []
